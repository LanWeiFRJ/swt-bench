# 离线运行说明

## 是否可以在不联网状态下运行？

**部分可以**，但需要在**首次运行时联网**来准备必要的资源。之后可以在离线状态下运行评估。

---

## 需要联网的操作

### 1. **Docker 镜像构建阶段**（必需，但只需一次）

#### 基础镜像构建（`dockerfiles.py`）
- ❌ 拉取 `ubuntu:22.04` 基础镜像
- ❌ `apt update` 下载系统包
- ❌ 下载 Miniconda: `wget https://repo.anaconda.com/miniconda/...`

#### 环境镜像构建（`exec_spec.py`）
- ❌ 下载 `environment.yml` 文件（从 GitHub raw，使用 `requests.get`）
- ❌ 下载 `requirements.txt` 文件（从 GitHub raw，使用 `requests.get`）
- ❌ `conda create` 和 `conda install` - 下载 conda 包
- ❌ `pip install` - 下载 Python 包（如果未缓存）

**注意：** 
- `get_environment_yml_by_commit` 和 `get_requirements_by_commit` 函数使用 `@cache` 装饰器，首次下载后会缓存结果（缓存在 Python 进程内存中）
- 但完全离线时，如果 Python 进程重启，缓存会丢失，需要重新下载
- 这些文件是从 GitHub raw content API 下载：`https://raw.githubusercontent.com/{repo}/{commit}/{path}`

#### 实例镜像构建（`exec_spec.py`）
- ❌ `git clone https://github.com/{repo}` - 从 GitHub 克隆仓库
- ❌ 可能还有其他依赖安装命令

**解决方案：**
- ✅ 首次联网时构建好所有需要的镜像
- ✅ 之后离线运行时，如果镜像已存在，Docker 会直接使用本地镜像

---

### 2. **数据集加载**（可选，支持本地）

**代码位置：** `src/dataset.py`

```python
# 支持两种方式：
# 1. 从本地文件加载（不需要联网）
if name.endswith(".json") or name.endswith(".jsonl"):
    return json.load(open(name))

# 2. 从 Hugging Face 加载（需要联网）
else:
    dataset = load_dataset(name, split=split)
```

**解决方案：**
- ✅ 使用本地 `.json` 或 `.jsonl` 文件
- ✅ 或者提前下载 Hugging Face 数据集到本地

---

### 3. **生成预测**（可选功能）

**代码位置：** `src/generate_predictions.py`

- ❌ 调用 OpenRouter API 生成预测

**解决方案：**
- ✅ 如果已经有预测文件（`.jsonl` 格式），可以跳过此步骤
- ✅ 使用 `--predictions_path` 参数指向本地预测文件

---

### 4. **执行评估**（如果镜像已存在，不需要联网）

**代码位置：** `src/run_evaluation.py`

- ✅ 如果 Docker 镜像已存在，执行评估时**不需要联网**
- ✅ 所有的测试执行都在本地 Docker 容器中进行

---

## 离线运行步骤

### 准备阶段（需要联网）

1. **构建所有需要的 Docker 镜像**
   ```bash
   # 运行一次完整的评估，让系统构建所有镜像
   python -m src.main \
       --dataset_name SWE-bench_Lite \
       --split test \
       --predictions_path your_predictions.jsonl \
       --run_id test_build_images
   ```
   
   或者使用 `prepare_images.py` 预先构建镜像：
   ```bash
   python -m src.prepare_images \
       --dataset_name SWE-bench_Lite \
       --split test \
       --instance_ids instance1 instance2 ...
   ```

2. **准备数据集文件**
   - 下载数据集到本地 `.json` 或 `.jsonl` 文件
   - 或使用 Hugging Face 的 `load_from_disk` 功能缓存到本地

3. **准备预测文件**
   - 如果有预测文件，确保保存在本地
   - 或使用 `gold` 模式（使用数据集中的黄金patch）

### 离线运行阶段

1. **断开网络连接**

2. **运行评估**
   ```bash
   python -m src.main \
       --dataset_name /path/to/local/dataset.json \
       --split test \
       --predictions_path /path/to/predictions.jsonl \
       --run_id offline_run \
       --cache_level all  # 使用所有缓存，不删除镜像
   ```

3. **注意事项**
   - 使用 `--cache_level all` 确保不删除已存在的镜像
   - 不要使用 `--force_rebuild`，这会尝试重新下载
   - 确保所有需要的实例镜像都已构建

---

## 完全离线运行检查清单

### ✅ 必需条件

- [ ] 所有 Docker 镜像已构建（base、env、instance）
- [ ] 数据集文件已下载到本地
- [ ] 预测文件已准备好（或使用 `gold` 模式）
- [ ] Docker 守护进程正在运行

### ⚠️ 可能的问题

1. **镜像不存在**
   - 如果某个实例的镜像不存在，构建过程会失败
   - 解决：预先构建所有需要的镜像

2. **Docker 基础镜像不存在**
   - 如果 `ubuntu:22.04` 镜像不在本地，需要联网拉取
   - 解决：首次运行时联网拉取并保存

3. **conda/pip 包缓存**
   - 如果包的缓存不存在，安装可能失败
   - 解决：首次运行时确保所有包都已下载并缓存

---

## 验证是否可以离线运行

运行以下命令检查镜像是否存在：

```bash
# 检查基础镜像
docker images | grep "exec.base"

# 检查环境镜像
docker images | grep "exec.env"

# 检查实例镜像
docker images | grep "exec.eval"
```

如果所有需要的镜像都存在，则可以离线运行评估。

---

## 总结

**离线运行可行性：**

| 阶段 | 是否需要联网 | 说明 |
|------|------------|------|
| **评估执行** | ✅ 不需要 | 如果 Docker 镜像已构建，可以完全离线运行 |
| **Docker 镜像构建** | ❌ 需要 | 需要下载基础镜像、系统包、conda、git clone 仓库等 |
| **环境配置文件下载** | ❌ 需要 | 需要从 GitHub 下载 `environment.yml` 和 `requirements.txt` |
| **数据集加载** | ✅ 不需要 | 可以使用本地 `.json` 或 `.jsonl` 文件 |
| **生成预测** | ❌ 需要 | 需要调用 API（但可以使用已有预测文件） |

**完全离线运行的限制：**

1. ⚠️ **Python 缓存问题**：`environment.yml` 和 `requirements.txt` 的缓存只在 Python 进程内存中，进程重启后会丢失
2. ⚠️ **首次构建必需联网**：所有 Docker 镜像首次构建时必须联网
3. ⚠️ **强制重建会失败**：使用 `--force_rebuild` 会尝试重新下载

**推荐做法：**

1. ✅ **首次运行在联网环境下**，让系统构建所有需要的镜像并缓存环境配置文件
2. ✅ **之后可以在离线环境下运行评估**（如果镜像已存在）
3. ✅ 使用 `--cache_level all` 保持镜像不被删除
4. ✅ 使用本地数据集文件而不是从 Hugging Face 下载
5. ✅ 使用已有的预测文件或 `gold` 模式，避免调用 API

**最佳实践：**

- 在联网环境下预先构建所有需要的镜像
- 将数据集下载到本地文件
- 准备预测文件（或使用 `gold` 模式）
- 之后可以在同一 Python 进程的后续运行中离线工作（因为缓存存在）
- 如果需要完全离线且重启进程，可能需要修改代码以支持本地配置文件

